using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Serialization;

namespace UblSharp.Tests.Generator
{

    // simple recursive code generator
    public class XmlToCs
    {
        private const string scFileHeaderContentFormat = @"// Generated by UblSharp.Tests.Generator
using System;
using System.Collections.Generic;
using System.Xml;
using UblSharp;
using UblSharp.CommonAggregateComponents;
using UblSharp.CommonExtensionComponents;
using UblSharp.UnqualifiedDataTypes;
using UblSharp.XmlDigitalSignature;
using UblSharp.Tests.Util;

namespace UblSharp.Tests.Samples
{{
    internal class {0}
    {{
        public static {1} Create()
        {{";

        private const string scFileFooterContent = @"
        }
    }
}
";

        private const int maxLevel = 20;
        private static string[] tabs = Enumerable.Range(0, maxLevel).Select(n => new string(' ', n * 4)).ToArray();

        private static List<Type> decimalUblUdtTypes = typeof(BaseDocument).Assembly.GetTypes()
            .Where(t => t.GetProperty("Value")?.PropertyType == typeof(decimal))
            .ToList();

        private static List<Type> binaryUblUdtTypes = typeof(BaseDocument).Assembly.GetTypes()
            .Where(t => t.GetProperty("Value")?.PropertyType == typeof(byte[]))
            .ToList();

        private static List<Type> oneLineAssignableUblUdtTypes = typeof(BaseDocument).Assembly.GetTypes()
            .Where(t => t.GetMethods(BindingFlags.Public | BindingFlags.Static).Where(m => m.Name == "op_Implicit").Any())
            .ToList();

        private Type docType;
        private XElement rootElement;
        private string xmlFilename;
        StringBuilder sb;

        public XmlToCs(XElement root, Type docType, string xmlFilename)
        {
            this.rootElement = root;
            this.docType = docType;
            this.xmlFilename = xmlFilename;
            this.sb = new StringBuilder();
        }


        public string XmlFilename
        {
            get { return xmlFilename; }
        }

        public Type DocType
        {
            get { return docType; }
        }

        public string CSharpFilename
        {
            get { return Path.ChangeExtension(xmlFilename, ".cs"); }
        }

        public string IdentifierName
        {
            get { return CodeIdentifier.MakePascal(Path.GetFileNameWithoutExtension(xmlFilename)); }
        }

        public bool HasExtensionsOrSignature { get; set; }

        public bool GenerateSourceCode()
        {
            int tabLevel = 3;
            string scFileHeaderContent = string.Format(scFileHeaderContentFormat, this.IdentifierName, this.docType.Name);
            WriteLine(0, scFileHeaderContent);
            Write(tabLevel, "var doc = ");
            GenerateNewClassStatement(rootElement, docType, tabLevel, ";");
            Write(tabLevel, "doc.Xmlns = ");
            GenerateNamespaceDeclaration(tabLevel);
            if (rootElement.Elements().All(x => x.Name.LocalName != "UBLVersionID"))
            {
                WriteLine(tabLevel, "doc.UBLVersionID = null;");
            }
            Write(tabLevel, "return doc;");
            Write(0, scFileFooterContent);
            return true;
        }

        internal void SaveToDir(string cSharpOutputDir)
        {
            string fullPath = Path.Combine(cSharpOutputDir, CSharpFilename);
            using (TextWriter writer = File.CreateText(fullPath))
            {
                writer.Write(sb.ToString());
            }
        }

        private void GenerateNewClassStatement(XElement xElement, Type propType, int tabLevel, string delimiter)
        {
            var propTypeName = propType.Name;
            WriteLine(0, $"new {propType.Name}");
            WriteLine(tabLevel, "{");
            if (xElement.HasElements)
            {
                string localDelimiter = ",";
                var xElements = xElement.Elements().Where(e => !e.IsEmpty).GroupBy(g => g.Name.LocalName).ToList();
                foreach (var elem in xElements)
                {
                    string xmlElementName = elem.First().Name.LocalName;
                    // Flag extension and signature features as unsupported/not implemented for now
                    if (xmlElementName == "UBLExtension")
                    {
                        // Don't know how to handle this one yet. ExtensionContent = "new XElement.Parse(something)"? or change ExtensionContent to object with xmltypeattributes
                        // HasExtensionsOrSignature = true;
                        // continue;
                    }
                    if (xmlElementName == "Signature" || xmlElementName == "UBLExtensions")
                    {
                        // HasExtensionsOrSignature = true;
                    }

                    PropertyInfo propInfo = GetPropertyThatMightBeRenamed(propType, xmlElementName);
                    if (propInfo == null)
                    {
                        Console.WriteLine("Warning, don't know how to handle: " + xmlElementName);
                        continue;
                    }

                    string cSharpPropName = propInfo.Name;
                    Write(tabLevel + 1, $"{cSharpPropName} = ");
                    if (elem == xElements.Last())
                        localDelimiter = string.Empty;
                    if (CanBeGeneratedAsOneLinerAssignment(xElement, propInfo.PropertyType))
                    {
                        string value = GetValue(xElement, propInfo.PropertyType);
                        WriteLine(0, $"{value}{delimiter}");
                    }
                    else if (propInfo.PropertyType.IsArray)
                    {
                        GenerateNewArrayStatement(elem.ToArray(), propInfo.PropertyType, tabLevel + 1, localDelimiter);
                    }
                    else if (propInfo.PropertyType.IsGenericType
                             && propInfo.PropertyType.GetGenericTypeDefinition() == typeof(List<>))
                    {
                        var elType = propInfo.PropertyType.GenericTypeArguments[0];
                        var elements = elem.ToArray();
                        var extensionElement = elements.FirstOrDefault();
                        if (extensionElement?.Name.LocalName == "UBLExtensions")
                        {
                            elements = extensionElement.Elements().ToArray();
                        }
                        GenerateNewListStatement(elements, propInfo.PropertyType, tabLevel + 1, ",");
                    }
                    else if (propInfo.PropertyType.Name == "XmlElement")
                    {
                        GenerateXmlElementAssignmentValue(elem.First(), propInfo.PropertyType, tabLevel + 1, localDelimiter);
                    }
                    else
                    {
                        GeneratePropertyAssignmentValue(elem.First(), propInfo.PropertyType, tabLevel, localDelimiter);
                    }
                }
            }
            else
            {
                foreach (var attribute in xElement.Attributes())
                {
                    WriteLine(tabLevel + 1, attribute.ToString().Replace("=", " = ") + ",");
                }
                string value = GetValue(xElement, propType);
                WriteLine(tabLevel + 1, $"Value = {value}");
            }
            WriteLine(tabLevel, $"}}{delimiter}");
        }

        private PropertyInfo GetPropertyThatMightBeRenamed(Type propType, string name)
        {
            var propInfo = propType.GetProperty(name);
            if (propInfo == null)
                propInfo = propType.GetProperty(name + "1");
            if (propInfo == null)
                propInfo = propType.GetProperty(name + "2");
            return propInfo;
        }

        private string GetValue(XElement xElement, Type propType)
        {
            string value = xElement.Value;
            if (decimalUblUdtTypes.Contains(propType))
            {
                return value + "M";
            }
            if (propType == typeof(UblSharp.UnqualifiedDataTypes.IndicatorType))
            {
                return value;
            }
            if (value.Contains("\""))
                value = value.Replace("\"", "\\\"");
            value = "\"" + value + "\"";
            if (value.IndexOfAny(new char[] { '\r', '\n' }) > 0)
                value = "@" + value;
            if (binaryUblUdtTypes.Contains(propType) || propType == typeof(byte) || propType == typeof(byte[]))
            {
                value = "Convert.FromBase64String(" + value + ")";
            }
            return value;
        }

        private void GenerateNewArrayStatement(XElement[] xElements, Type arrayPropType, int tabLevel, string delimiter)
        {
            WriteLine(0, $"new {arrayPropType.Name}");
            WriteLine(tabLevel, "{");
            var itemType = arrayPropType.GetElementType();
            string localDelimiter = ",";
            foreach (var item in xElements)
            {
                Write(tabLevel + 1, "");
                if (item == xElements.Last())
                    localDelimiter = string.Empty;
                GenerateNewClassStatement(item, itemType, tabLevel + 1, localDelimiter);
            }
            WriteLine(tabLevel, $"}}{delimiter}");
        }

        private void GenerateNewListStatement(XElement[] xElements, Type arrayPropType, int tabLevel, string delimiter)
        {
            var elType = arrayPropType.GenericTypeArguments[0];

            WriteLine(0, $"new List<{elType.Name}>()");
            WriteLine(tabLevel, "{");

            string localDelimiter = ",";
            foreach (var item in xElements)
            {
                Write(tabLevel + 1, "");
                if (item == xElements.Last())
                    localDelimiter = string.Empty;
                GenerateNewClassStatement(item, elType, tabLevel + 1, localDelimiter);
            }
            WriteLine(tabLevel, $"}}{delimiter}");
        }

        private void GenerateXmlElementAssignmentValue(XElement xElement, Type propertyType, int tabLevel, string delimiter)
        {
            string innerXml;
            using (var rdr = xElement.CreateReader())
            {
                rdr.MoveToContent();
                innerXml = rdr.ReadInnerXml();
            }
            WriteLine(0, $@"@""{innerXml.Replace("\"", "\"\"")}"".ToXmlElement()");
        }

        private void GeneratePropertyAssignmentValue(XElement xElement, Type propertyType, int tabLevel, string delimiter)
        {
            if (CanBeGeneratedAsOneLinerAssignment(xElement, propertyType))
            {
                string value = GetValue(xElement, propertyType);
                WriteLine(0, $"{value}{delimiter}");
            }
            else
            {
                GenerateNewClassStatement(xElement, propertyType, tabLevel + 1, delimiter);
            }
        }

        private bool CanBeGeneratedAsOneLinerAssignment(XElement xElement, Type propertyType)
        {
            if (propertyType == typeof(byte[]))
            {
                return true;
            }

            var hasAttributes = xElement.Attributes().Where(a => a.IsNamespaceDeclaration == false).Any();
            if (xElement.HasElements || hasAttributes)
                return false;

            // Only basetypes from UblSharp.UnqualifiedDataTypes having static implicit assignment functions can be assigned as a one-liner when Attributes and Elements are empty
            var ublType = propertyType.Assembly == typeof(BaseDocument).Assembly;
            if (ublType)
            {
                if (oneLineAssignableUblUdtTypes.Contains(propertyType))
                    return true;
                return false;
            }
            return true;
        }

        private void GenerateNamespaceDeclaration(int tabLevel)
        {
            var namespacePrefixDeclarations = rootElement.Attributes().Where(a => a.Name.NamespaceName.Any()).ToList();

            WriteLine(0, "new System.Xml.Serialization.XmlSerializerNamespaces(new[]");
            WriteLine(tabLevel, "{");
            foreach (var nsAttribute in namespacePrefixDeclarations)
            {
                WriteLine(tabLevel + 1, $"new XmlQualifiedName(\"{nsAttribute.Name.LocalName}\",\"{nsAttribute.Value}\"),");
            }
            WriteLine(tabLevel, "});");
        }

        private void WriteLine(int tabLevel, string s)
        {
            sb.AppendLine($"{tabs[tabLevel]}{s}");
        }

        private void Write(int tabLevel, string s)
        {
            sb.Append($"{tabs[tabLevel]}{s}");
        }
    }
}