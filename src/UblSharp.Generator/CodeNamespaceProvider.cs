using System;
using System.CodeDom;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Schema;
using UblSharp.Generator.Extensions;

namespace UblSharp.Generator
{
    public class CodeNamespaceProvider
    {
        private const string NamespaceHeader = @"------------------------------------------------------------------------------
 <auto-generated>
     This code was generated by a tool.

     Manual changes to this file will be overwritten if the code is regenerated.

 </auto-generated>
------------------------------------------------------------------------------";
        private readonly XmlSchemaSet _schemaSet;

        private Dictionary<string, string[]> _namespaceMappings = new Dictionary<string, string[]>
        {
            [""] = new[] { "udt", "cac", "ext" },
            ["cac"] = new[] { "udt" },
            ["ext"] = new[] { "udt" },
            ["udt"] = new[] { "cctscct", "sbc", "ext" },
            ["sbc"] = new[] { "udt" },
            ["cctscct"] = new[] { "udt", "sbc", "ext" },
            ["abs"] = new[] { "udt", "cac", "ext" },
            ["xades"] = new[] { "ds" },
            ["sac"] = new[] { "udt", "sbc", "ds" },
            ["csc"] = new[] { "sac" }
        };

        private Dictionary<string, string> _realNamespaces = new Dictionary<string, string>
        {
            [""] = "",
            ["cac"] = "CommonAggregateComponents",
            ["ext"] = "CommonExtensionComponents",
            ["udt"] = "UnqualifiedDataTypes",
            ["sbc"] = "SignatureBasicComponents",
            ["cctscct"] = "CoreComponentTypes",
            ["ccts-cct"] = "CoreComponentTypes",
            ["ccts"] = "CoreComponentTypes",
            ["cct"] = "CoreComponentTypes",
            ["abs"] = "",
            ["xades"] = "Xades",
            ["sac"] = "SignatureAggregateComponents",
            ["csc"] = "CommonSignatureComponents",
            ["cbc"] = "CommonBasicComponents",
            ["qdt"] = "QualifiedDataTypes",
            ["ds"] = "XmlDigitalSignature",
        };

        private Dictionary<string, string> _xml2CSharpNamespaceMapping;
        private Dictionary<string, string> _namespace2Foldermapping;
        private readonly string[] _unwantedPrefixes = { "", "xsd", "abs", "cct" };
        private readonly string[] _unwantedFolderPrefixes = { "", "xsd" };

        public CodeNamespaceProvider(XmlSchemaSet schemaSet, UblGeneratorOptions options)
        {
            _schemaSet = schemaSet;

            _xml2CSharpNamespaceMapping = schemaSet.Schemas().Cast<XmlSchema>()
                .SelectMany(schema => schema.Namespaces.ToArray().Where(qname => !_unwantedPrefixes.Contains(qname.Name)))
                .Select(qname => new { qname.Namespace, qname.Name })
                .Distinct()
                .ToDictionary(key => key.Namespace, val => $"{options.Namespace}.{_realNamespaces[val.Name]}");

            _namespace2Foldermapping = schemaSet.Schemas().Cast<XmlSchema>()
                .SelectMany(schema => schema.Namespaces.ToArray().Where(qname => !_unwantedFolderPrefixes.Contains(qname.Name)))
                .Select(qname => new { qname.Namespace, qname.Name })
                .GroupBy(x => x.Namespace)
                .ToDictionary(key => key.Key, val => $"{_realNamespaces[val.First().Name]}");

            var mainSchemas = schemaSet.Schemas().Cast<XmlSchema>().Where(x => x.SourceUri.Contains("maindoc"));
            foreach (var schema in mainSchemas)
            {
                var targetNamespace = schema.TargetNamespace;
                if (!_xml2CSharpNamespaceMapping.ContainsKey(targetNamespace))
                {
                    _xml2CSharpNamespaceMapping[targetNamespace] = options.Namespace;
                }
            }

            _namespaceMappings = _namespaceMappings.ToDictionary(k => options.Namespace + (k.Key == "" ? "" : ".") + _realNamespaces[k.Key], v => v.Value.Select(n => _realNamespaces[n]).ToArray());

            _xml2CSharpNamespaceMapping[Namespaces.Csc] = $"{options.Namespace}.{_realNamespaces["csc"]}";
            _xml2CSharpNamespaceMapping[Namespaces.Xades132] = $"{options.Namespace}.{_realNamespaces["xades"]}";
            _xml2CSharpNamespaceMapping[Namespaces.Xades141] = $"{options.Namespace}.{_realNamespaces["xades"]}";
            _namespace2Foldermapping[Namespaces.Csc] = $"{_realNamespaces["csc"]}";
            _namespace2Foldermapping[Namespaces.Xades132] = $"{_realNamespaces["xades"]}";
            _namespace2Foldermapping[Namespaces.Xades141] = $"{_realNamespaces["xades"]}";
        }

        public CodeNamespace CreateCodeNamespace(string xmlNamespace)
        {
            if (_xml2CSharpNamespaceMapping.ContainsKey(xmlNamespace))
            {
                var csScopeName = _xml2CSharpNamespaceMapping[xmlNamespace];
                var codeNs = new CodeNamespace(csScopeName);

                codeNs.Comments.Add(new CodeCommentStatement(new CodeComment(NamespaceHeader)));

                if (xmlNamespace.Equals(Namespaces.BaseDocument))
                {
                    csScopeName += ".Abs";
                }

                if (_namespaceMappings.ContainsKey(csScopeName))
                {
                    foreach (var usingNamespace in _namespaceMappings[csScopeName])
                    {
                        codeNs.Imports.Add(new CodeNamespaceImport(usingNamespace));
                    }
                }
                return codeNs;
            }
            else
            {
                throw new InvalidOperationException("Cannot find namespace for: " + xmlNamespace);
            }
        }

        public string GetNamespaceFolderName(XmlSchema schema)
        {
            if (schema.IsMaindocSchema() || schema.SourceUri.Contains("BaseDocument"))
            {
                return "maindoc";
            }

            return _namespace2Foldermapping[schema.TargetNamespace];
        }
    }
}
